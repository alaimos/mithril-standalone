package com.alaimos.SPECifIC.Data.Structures;

import com.alaimos.Commons.Math.PValue.EmpiricalBrowns.EmpiricalBrownsMethod;
import com.alaimos.MITHrIL.Data.Pathway.Interface.NodeInterface;
import com.alaimos.MITHrIL.Data.Pathway.Interface.PathwayInterface;
import com.pengyifan.commons.collections.tree.Tree;

import java.util.Arrays;
import java.util.Collection;
import java.util.stream.Collectors;

/**
 * A non-navigable object which represents the induced sub-graph generated by a VisitTree
 *
 * @author Salvatore Alaimo, Ph.D.
 * @version 2.0.0.0
 * @since 16/12/2016
 */
public class CommunitySubGraph extends InducedSubGraph {

    private VisitTree[] trees;

    public CommunitySubGraph(VisitTree[] trees, PathwayInterface origin) {
        this.tree = null;
        this.trees = trees;
        if (trees.length < 2) {
            throw new RuntimeException("You need at least 2 DFS trees");
        }
        this.origin = origin;
        this.init();
    }

    @Override
    protected void init() {
        Collection<GraphVisitNode> tmp = Arrays.stream(trees).flatMap(VisitTree::stream).map(Tree::getObject)
                                               .collect(Collectors.toMap(o -> o.getNode().getId(), o -> o, (u, v) -> u))
                                               .values();
        nodes = tmp.stream().map(GraphVisitNode::getNode).toArray(NodeInterface[]::new);
        perturbations = tmp.stream().mapToDouble(GraphVisitNode::getPerturbation).toArray();
        pValues = tmp.stream().mapToDouble(GraphVisitNode::getPValue).toArray();
        EmpiricalBrownsMethod.setFilter(tmp.stream().map(n -> n.getNode().getId()).toArray(String[]::new));
        pValue = trees[0].getCombiner().combine(pValues);
        computeAccumulator();
        computeEdges();
    }
}
